"""
Some auxiliary entities not falling into the other categories
"""

import collections.abc
import logging
import pathlib
import shlex
import subprocess
import sys
from typing import Any, List, Mapping

import stm32pio.core.log


def _get_version_from_scm() -> str:
    try:
        import setuptools_scm  # setuptools_scm is the dev-only dependency
    except ImportError:
        return "Portable (not-installed). See git tag"
    else:
        # Calculate the version in real-time from the Git repo state
        return setuptools_scm.get_version(root='../..', relative_to=__file__)


def get_version() -> str:
    """Retrieve the app version as string"""
    if sys.version_info >= (3, 8):
        import importlib.metadata
        try:
            # For modern Python use the package metadata (if we are installed). For this to be available the wheel build
            # should be done with setuptools_scm
            return importlib.metadata.version('stm32pio')
        except importlib.metadata.PackageNotFoundError:
            # stm32pio is not installed (i.e. running from sources)
            return _get_version_from_scm()
    else:
        try:
            # Version is stored in the stm32pio/core/version.py file auto-generated by setuptools_scm tool
            import stm32pio.core.version
        except ImportError:
            # Version file is not available, most likely we are not installed (i.e. running from sources)
            return _get_version_from_scm()
        else:
            return stm32pio.core.version.version


def cleanup_mapping(mapping: Mapping[str, Any]) -> dict:
    """Return a deep copy of the given mapping excluding None and empty string values"""

    cleaned = {}

    for key, value in mapping.items():
        if isinstance(value, collections.abc.Mapping):
            cleaned[key] = cleanup_mapping(value)
        elif value is not None and value != '':
            cleaned[key] = value

    return cleaned


def get_folder_contents(path: pathlib.Path, pattern: str = '*',
                        ignore_list: List[pathlib.Path] = None) -> List[pathlib.Path]:
    """
    Return all endpoints inside the given directory (recursively). If specified, paths from the ignore_list will be
    excluded. The resulting array is fully "unfolded" meaning every folder will be expanded, so both it and its children
    will be included into the list. Conversely, the ignore_list is treated in the opposite way so for every folder met
    both it and its children will be ignored completely.

    Note: this is a "naive", straightforward and non-efficient solution (probably, both for time and memory
    consumption). The algorithm behind can (but not necessarily should) definitely be improved.

    Args:
        path: root directory
        pattern: optional glob-style pattern string to use. Default one will pass all
        ignore_list: optional list of pathlib Paths to ignore (see the full description)

    Returns:
        list of pathlib Paths
    """

    folder_contents = []

    if ignore_list is not None:
        ignore_list = sorted(ignore_list)
    else:
        ignore_list = []

    for child in sorted(path.rglob(pattern)):  # all files and folders, recursively

        # Here we check such cases:
        #   1) current child:        a/b/
        #      ignore list entry:    a/b/c/d.txt
        #
        #   2) current child:        a/b/c/d.txt
        #      ignore list entry:    a/b/
        is_root_of_another = next(
            (True for entry in ignore_list if (child in entry.parents) or (entry in child.parents)), False)

        if (child not in ignore_list) and (not is_root_of_another):
            folder_contents.append(child)

    return folder_contents


def start_editor(editor_command: str, path: pathlib.Path, logger: logging.Logger) -> int:
    """
    Start the editor specified by the 'editor_command' with a project directory opened (assuming that
        $ [editor] [folder]
    syntax just works)

    Args:
        editor_command: editor command as you start it in the terminal

    Returns:
        passes a return code of the command
    """

    sanitized_input = shlex.quote(editor_command)

    logger.info(f"starting an editor '{sanitized_input}'...")
    try:
        with stm32pio.core.log.LogPipe(logger, logging.DEBUG) as log:
            # Works unstable on some Windows 7 systems, but correct on Win10...
            # result = subprocess.run([editor_command, self.path], check=True)
            completed_process = subprocess.run(f'{sanitized_input} "{path}"', shell=True, check=True,
                                               stdout=log.pipe, stderr=log.pipe)
        logger.debug(completed_process.stdout, extra={'from_subprocess': True})

        return completed_process.returncode
    except subprocess.CalledProcessError as e:
        logger.error(f"failed to start the editor '{sanitized_input}': {e.stdout}")
        return e.returncode
